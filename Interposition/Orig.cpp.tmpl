{% import 'Interposition/macros.tmpl' as macros -%}
//
//  Orig.cpp
//  LibraryFaultInjection
//
//  Created by Laurynas Karazija on 01/01/2016.
//  Copyright (C) 2016 Laurynas Karazija. All rights reserved.
//
//
//  This file is automatically generated
//


//Macros
#define ENVREADTEST "FIT_ENV_READ_TEST"
#define INJECTIONMODE "FIT_INJECTION_MODE"
#define CONTROL_FILE "FIT_CONTROL_FILE"


#include <stdlib.h>
#include <string.h>
#include <dlfcn.h>
#include <new>
#include <mutex>
#include <utime.h>
#include "Orig.hpp"


namespace FIT{
    Orig Original;
    bool initialised_flag(false);
    bool insideFIT(false);
}

size_t stringlen(const char* ptr){
    return strlen(ptr);
}

int rnd(){
    //indirect for rand() function
    return rand();
}

static bool mapFunctions(){
    {% for func in fn_list if 'nogen' not in func.flags and 'shorted' not in func.flags and 'vararg' not in func.flags -%}
    FIT::Original.{{func.name}}_ = ({{func.ret}} (*)({{macros.fn_signature(func)}})) dlsym(RTLD_NEXT, "{{func.name}}");
    {% endfor %}

    bool value ={% for func in fn_list if 'nogen' not in func.flags and 'shorted' not in func.flags and 'vararg' not in func.flags -%}
    (FIT::Original.{{func.name}}_ != NULL) {% if not loop.last %}{{"&&"}}{% else %};{% endif %}
    {% endfor %}

    return value;
}

static std::mutex init_start_mux;

void __FIT__injectionInit(){
    init_start_mux.lock();
    if (!FIT::initialised_flag){
        //FIT::Original.fputs_("Initialising Start\n\0", stdout);

        FIT::initialised_flag = true;
        //Prevent reentry into init functions

        FIT::insideFIT = true;

        bool funcs = mapFunctions();
        #ifdef __APPLE__
        FIT::Original.fputs_("Functions loaded; check not performed\n\0", stdout);
        #else
        if (!funcs) abort();
        #endif
        FIT::Original.fputs_("Functions found\n\0", stdout);
        const char* s = getenv(ENVREADTEST);
        if (s== NULL || strcmp(s, "TEST")!=0){
            abort(); //ENVironment cannot be acceses ->Control cannot be passed
        }


        s = getenv(CONTROL_FILE);
        if (s==NULL) abort();
        FILE* control = FIT::Original.fopen_(s, "r");
        if (control==NULL) abort();

        size_t nbytes = 100;
        char buffer[nbytes];
        char* line= buffer;
        ssize_t readbytes;

        readbytes = FIT::Original.getline_(&line, &nbytes, control);
        if (readbytes <= 0)
            abort();
        FIT::Original.injection_flag = (bool) (line[0]-'0');

        bool loggingFlag;
        bool inputLoggingFlag;
        bool shortLogFlag;

        readbytes = FIT::Original.getline_(&line, &nbytes, control);
        if (readbytes <= 0)
            abort();
        loggingFlag = (bool) (line[0]-'0');
        inputLoggingFlag = true;
        shortLogFlag = false;

        FIT::Original.debugmode_flag = false;
        readbytes = FIT::Original.getline_(&line, &nbytes, control);
        if (readbytes <= 0)
            abort();
        FIT::Original.debugmode_flag = (bool) (line[0]-'0');

        readbytes = FIT::Original.getline_(&line, &nbytes, control);
        if (readbytes <= 0)
            abort();
        FIT::Original.recovery_flag = (bool) (line[0]-'0');

        {% for func in fn_list if 'nogen' not in func.flags and 'shorted' not in func.flags and 'vararg' not in func.flags-%}
        FIT::Original.{{func.name}}_count = 0;
        readbytes = FIT::Original.getline_(&line, &nbytes, control);
        if (readbytes <= 0)
            abort();
        FIT::Original.{{func.name}}_flag = (int) (line[0]-'0');
        {% endfor %}


        readbytes = FIT::Original.getline_(&line, &nbytes, control);
        if (readbytes <= 0)
            abort();
        line[readbytes-1] = '\0';
        char pFileName[readbytes];
        strcpy(pFileName, line);
        readbytes = FIT::Original.getline_(&line, &nbytes, control);
        if (readbytes <= 0)
            abort();
        line[readbytes-1] = '\0';
        char mFileName[readbytes];
        strcpy(mFileName, line);
        readbytes = FIT::Original.getline_(&line, &nbytes, control);
        if (readbytes <= 0)
            abort();
        line[readbytes-1] = '\0';
        char oFileName[readbytes];
        strcpy(oFileName, line);
        readbytes = FIT::Original.getline_(&line, &nbytes, control);
        if (readbytes <= 0)
            abort();
        line[readbytes-1] = '\0';
        char eFileName[readbytes];
        strcpy(eFileName, line);
        readbytes = FIT::Original.getline_(&line, &nbytes, control);
        if (readbytes <= 0)
            abort();
        line[readbytes-1] = '\0';
        char iFileName[readbytes];
        strcpy(iFileName, line);

        FIT::Original.fclose_(control);

        //TRY to create a logfile
        FIT::Original.logFile = (FIT::Logfile*) malloc(sizeof(FIT::Logfile));
        if (FIT::Original.logFile!=NULL){
            FIT::Original.logFile = new(FIT::Original.logFile) FIT::Logfile(shortLogFlag,loggingFlag, inputLoggingFlag, oFileName, mFileName, eFileName, iFileName, pFileName);
        } else {
            abort(); //Logging impossible ->Cannot track execution
        }
        FIT::insideFIT = false;
        FIT::initialised_flag=true;
        //FIT::Original.fputs_("Initialising Fin\n\0", stdout);
    }
    init_start_mux.unlock();
}

void __FIT__injectionFin(){
    if (FIT::initialised_flag){
        FIT::Original.logFile->~Logfile();
        free(FIT::Original.logFile);
    }
}
