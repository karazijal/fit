{% import 'Interposition/macros.tmpl' as macros -%}
//
//  Interpos.cpp
//  LibraryFaultInjection
//
//  Created by Laurynas Karazija on 01/01/2016.
//  Copyright (C) 2016 Laurynas Karazija. All rights reserved.
//
//
//  This file is automatically generated
//

//#define _GNU_SOURCE
#include <errno.h>
#include <stdarg.h>
#include <stdlib.h>
#include <fcntl.h>
#include <execinfo.h>
#include "Orig.hpp"

static bool opTest(int func_flag, int fire_flag){
    //Should we inject
    if (func_flag == 0)
        return false;
    if (func_flag == 1)
        return true;
    if (fire_flag == 0)
        return true;
    return false;
}
extern "C" {
//Functions that *could/should* be written by hand:
{% for func in fn_list if 'nogen' not in func.flags and 'vararg' not in func.flags and 'shorted' not in func.flags and 'nonauto' in func.flags -%}
    //{{macros.fn_def_macro_safe(func)}};
{% endfor %}
{% for func in fn_list if 'nogen' not in func.flags and 'nonauto' not in func.flags -%}
    {{macros.fn_def_macro_safe(func)}}{
    {# Case statements to handle the vararg redirect -#}
    {% if "vararg" in func.flags -%}
        va_list va_args;
        va_start(va_args, {{(func.args|last).name}});
        {%- if func.ret != "void" -%}
        {{func.ret}} _rtn = {{func.real_func}}({%- for arg in func.args -%}{{arg.name}}{%- if not loop.last -%}{{", "}}{%- endif -%}{%- endfor -%}, va_args);
        va_end(va_args);
        return _rtn;
        {%- else -%}
        {{func.real_func}}({%- for arg in func.args -%}{{arg.name}}{%- if not loop.last -%}{{", "}}{%- endif -%}{%- endfor -%}, va_args);
        va_end(va_args);
        return;
        {%- endif -%}
    {% elif "shorted" in func.flags-%}
    {# Case statements to handle the shorted redirect -#}
        return {{func.real_call}};
    {% else -%}
    {# Other case -#}
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.{{func.name}}_ == NULL){
        FIT::Original.logFile->log_call("{{func.name}} loading error\n");
        __FIT__injectionFin();
        abort();
    }
    {#- fd protect - start -#}
    {%- if "fdprotect" in func.flags -%}
    if (FIT::Original.logFile->isProtected({{func.fd_protect.arg}})){
        errno = {{func.fd_protect.errno}};
        return {{func.err_ret}};
    }
    {%- endif -%}
    {#- fd protect - end #}
    if(FIT::insideFIT){
        {% if "open" in func.flags %}
        mode_t mode = 0;
        if ((flags & O_CREAT) != 0)
        {
            va_list arg;
            va_start(arg, flags);
            mode = va_arg(arg, mode_t);
            va_end(arg);
        }
        return FIT::Original.{{func.name}}_({% if "dir" in func.flags %}dirfd,{% endif %} pathname, flags, mode);
        {% else %}
        return FIT::Original.{{macros.func_call(func)}};
        {% endif %}
    }
    FIT::insideFIT = true;
    {#- Orig code start #}
    static int fire_flag = FIT::Original.{{func.name}}_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    {%if func.args is string-%}
    {{func.args|declare_static_variables_string}}
    {%- else -%}
    {% for arg in func.args if "va_list" not in arg.type -%}
    static {{arg.type}} {{arg.name}}_rec={{arg.name}};
    {% endfor%}
    {%- endif%}
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            {%-if func.args is string%}
            {{func.args|compare_variables_string}}
            {% else %}
            {% for arg in func.args if "va_list" not in arg.type -%}
            {%-if arg is buffer-%}
            /*fxxfxxf*/ {{arg.name}}_rec==(const void*)((const char*){{arg.name}}-{%if func is with_size%}size/{%endif%}sizeof(char))&&
            {%-elif arg.name =="nb" and arg.type =="size_t"-%}
            /*fxxfxxe*/ {{arg.name}}_rec=={{arg.name}}-1&&
            {%-else-%}
            {{arg.name}}_rec=={{arg.name}}&&
            {%-endif%}
            {% endfor%}
            {%- endif-%}
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.{{func.name}}_flag, fire_flag) || recovery_detect){
        {# The non-injection case -#}
        fire_flag--;
        expect_recovery = false;
        {% if 'log' in func.flags %}
        {{macros.log_cases(func)}}
        {% else -%}
        FIT::insideFIT = false;
        {% if "open" in func.flags %}
        mode_t mode = 0;
        if ((flags & O_CREAT) != 0)
        {
            va_list arg;
            va_start(arg, flags);
            mode = va_arg(arg, mode_t);
            va_end(arg);
        }
        return FIT::Original.{{func.name}}_({% if "dir" in func.flags %}dirfd,{% endif %} pathname, flags, mode);
        {% else %}
        return FIT::Original.{{macros.func_call(func)}};
        {% endif %}
        {%- endif %}
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            {%if func.args is string%}
            {{func.args|assign_variables_string}}
            {% else -%}
            {%- for arg in func.args if "va_list" not in arg.type -%}
            {{arg.name}}_rec={{arg.name}};
            {% endfor%}
            {%- endif%}
        }
        fire_flag = FIT::Original.{{func.name}}_flag - 1;
        FIT::Original.{{func.name}}_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("{{func.name}} ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("{{func.name}}\n");
        }

    {#- The fault injection code -#}



    {%- if "errinj" in func.flags %}
        {{func.errline}}
        FIT::insideFIT = false;
        return {{func.err_ret}};



    {%- elif "log" in func.flags -%}



        {{macros.shortinj_cases(func)}}




    {%- else -%}



    //TODO: FIX THIS CODE:: 00FF01
    return FIT::Original.{{macros.func_call(func)}};

    {%- endif %}
    }
    {%- endif %}
}

{% endfor %}
}
