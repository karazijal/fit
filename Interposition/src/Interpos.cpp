//
//  Interpos.cpp
//  LibraryFaultInjection
//
//  Created by Laurynas Karazija on 01/01/2016.
//  Copyright (C) 2016 Laurynas Karazija. All rights reserved.
//
//
//  This file is automatically generated
//

//#define _GNU_SOURCE
#include <errno.h>
#include <stdarg.h>
#include <stdlib.h>
#include <fcntl.h>
#include <execinfo.h>
#include "Orig.hpp"

static bool opTest(int func_flag, int fire_flag){
    //Should we inject
    if (func_flag == 0)
        return false;
    if (func_flag == 1)
        return true;
    if (fire_flag == 0)
        return true;
    return false;
}
extern "C" {
//Functions that *could/should* be written by hand:
//int (vfscanf)(FILE * stream, const char * format, va_list ap);

int (vfprintf)(FILE * stream, const char * format, va_list ap){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.vfprintf_ == NULL){
        FIT::Original.logFile->log_call("vfprintf loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.vfprintf_(stream, format, ap);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.vfprintf_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static FILE * stream_rec=stream;
    static const char * format_rec=format;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            stream_rec==stream&&
            format_rec==format&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.vfprintf_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                int ret;
                int target_fd = fileno(stream);
                size_t bufsize_init =stringlen(format)+64;
                char f_tmp[bufsize_init-1];
                size_t  lim = vsnprintf(f_tmp,bufsize_init, format, ap);
                if (lim > bufsize_init){
                    char f_tmp2[lim+1];
                    size_t nmemb = vsnprintf(f_tmp2,lim+1, format, ap);
                    ret = (int) FIT::Original.fwrite_((void*) f_tmp2, sizeof(char), nmemb, stream);
                    
                    if (ret > 0){
                        FIT::Original.logFile->log_output_clx(target_fd,(void*) f_tmp2, sizeof(char), ret);
                    }
                } else {
                    ret = (int) FIT::Original.fwrite_((void*) f_tmp, sizeof(char), lim, stream);
                    
                    if (ret > 0){
                        FIT::Original.logFile->log_output_clx(target_fd,(void*) f_tmp, sizeof(char), ret);
                    }
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            stream_rec=stream;
            format_rec=format;
            
        }
        fire_flag = FIT::Original.vfprintf_flag - 1;
        FIT::Original.vfprintf_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("vfprintf ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("vfprintf\n");
        }
                
                int ret;
                int target_fd = fileno(stream);
                size_t bufsize_init =stringlen(format)+64;
                char f_tmp[bufsize_init];
                size_t  lim = vsnprintf(f_tmp,bufsize_init, format, ap);
                if (lim > bufsize_init-1){
                    char f_tmp2[lim+1];
                    size_t nmemb = vsnprintf(f_tmp2,lim+1, format, ap);

                    ret = (int) FIT::Original.fwrite_((void*) f_tmp2, sizeof(char), 1, stream);
                    
                    if (ret > 0){
                        FIT::Original.logFile->log_output_clx(target_fd,(void*) f_tmp2, sizeof(char), ret);
                    }
                } else {
                    ret = (int) FIT::Original.fwrite_((void*) f_tmp, sizeof(char), 1, stream);
                    
                    if (ret > 0){
                        FIT::Original.logFile->log_output_clx(target_fd,(void*) f_tmp, sizeof(char), ret);
                    }
                }
                
                FIT::insideFIT = false;
                return ret;
    }
}

int (vdprintf)(int fd, const char * format, va_list ap){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.vdprintf_ == NULL){
        FIT::Original.logFile->log_call("vdprintf loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.vdprintf_(fd, format, ap);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.vdprintf_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static const char * format_rec=format;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            format_rec==format&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.vdprintf_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                int ret;
                int target_fd = fd;
                size_t bufsize_init =stringlen(format)+64;
                char f_tmp[bufsize_init-1];
                size_t  lim = vsnprintf(f_tmp,bufsize_init, format, ap);
                if (lim > bufsize_init){
                    char f_tmp2[lim+1];
                    size_t nmemb = vsnprintf(f_tmp2,lim+1, format, ap);
                    ret = (int) FIT::Original.write_(fd, (void*) f_tmp2, sizeof(char)*nmemb);
                    if (ret > 0){
                        FIT::Original.logFile->log_output_clx(target_fd,(void*) f_tmp2, sizeof(char), ret);
                    }
                } else {
                    ret = (int) FIT::Original.write_(fd, (void*) f_tmp, sizeof(char)*lim);
                    if (ret > 0){
                        FIT::Original.logFile->log_output_clx(target_fd,(void*) f_tmp, sizeof(char), ret);
                    }
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            format_rec=format;
            
        }
        fire_flag = FIT::Original.vdprintf_flag - 1;
        FIT::Original.vdprintf_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("vdprintf ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("vdprintf\n");
        }
                
                int ret;
                int target_fd = fd;
                size_t bufsize_init =stringlen(format)+64;
                char f_tmp[bufsize_init];
                size_t  lim = vsnprintf(f_tmp,bufsize_init, format, ap);
                if (lim > bufsize_init-1){
                    char f_tmp2[lim+1];
                    size_t nmemb = vsnprintf(f_tmp2,lim+1, format, ap);

                    ret = (int) FIT::Original.write_(fd, (void*) f_tmp2, sizeof(char));
                    if (ret > 0){
                        FIT::Original.logFile->log_output_clx(target_fd,(void*) f_tmp2, sizeof(char), ret);
                    }
                } else {
                    ret = (int) FIT::Original.write_(fd, (void*) f_tmp, sizeof(char));
                    if (ret > 0){
                        FIT::Original.logFile->log_output_clx(target_fd,(void*) f_tmp, sizeof(char), ret);
                    }
                }
                
                FIT::insideFIT = false;
                return ret;
    }
}

int (fgetc_unlocked)(FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fgetc_unlocked_ == NULL){
        FIT::Original.logFile->log_call("fgetc_unlocked loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fgetc_unlocked_(stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fgetc_unlocked_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fgetc_unlocked_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                int ret = FIT::Original.fgetc_unlocked_(stream);
                if (ret!=-1) {
                    FIT::Original.logFile->log_input_c(ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.fgetc_unlocked_flag - 1;
        FIT::Original.fgetc_unlocked_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fgetc_unlocked ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fgetc_unlocked\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (fputc_unlocked)(int c, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fputc_unlocked_ == NULL){
        FIT::Original.logFile->log_call("fputc_unlocked loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fputc_unlocked_(c, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fputc_unlocked_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int c_rec=c;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            c_rec==c&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fputc_unlocked_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				

                int target_fd = fileno(stream);
                int ret = FIT::Original.fputc_unlocked_(c, stream);
                if (ret==c) {
                    FIT::Original.logFile->log_output_c(target_fd, c);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            c_rec=c;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.fputc_unlocked_flag - 1;
        FIT::Original.fputc_unlocked_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fputc_unlocked ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fputc_unlocked\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (__vfprintf_chk)(FILE * stream, int flag, const char * format, va_list ap){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__vfprintf_chk_ == NULL){
        FIT::Original.logFile->log_call("__vfprintf_chk loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__vfprintf_chk_(stream, flag, format, ap);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__vfprintf_chk_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static FILE * stream_rec=stream;
    static int flag_rec=flag;
    static const char * format_rec=format;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            stream_rec==stream&&
            flag_rec==flag&&
            format_rec==format&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__vfprintf_chk_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                int ret;
                int target_fd = fileno(stream);
                size_t bufsize_init =stringlen(format)+64;
                char f_tmp[bufsize_init-1];
                size_t  lim = vsnprintf(f_tmp,bufsize_init, format, ap);
                if (lim > bufsize_init){
                    char f_tmp2[lim+1];
                    size_t nmemb = vsnprintf(f_tmp2,lim+1, format, ap);
                    ret = (int) FIT::Original.fwrite_((void*) f_tmp2, sizeof(char), nmemb, stream);
                    
                    if (ret > 0){
                        FIT::Original.logFile->log_output_clx(target_fd,(void*) f_tmp2, sizeof(char), ret);
                    }
                } else {
                    ret = (int) FIT::Original.fwrite_((void*) f_tmp, sizeof(char), lim, stream);
                    
                    if (ret > 0){
                        FIT::Original.logFile->log_output_clx(target_fd,(void*) f_tmp, sizeof(char), ret);
                    }
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            stream_rec=stream;
            flag_rec=flag;
            format_rec=format;
            
        }
        fire_flag = FIT::Original.__vfprintf_chk_flag - 1;
        FIT::Original.__vfprintf_chk_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__vfprintf_chk ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__vfprintf_chk\n");
        }
                
                int ret;
                int target_fd = fileno(stream);
                size_t bufsize_init =stringlen(format)+64;
                char f_tmp[bufsize_init];
                size_t  lim = vsnprintf(f_tmp,bufsize_init, format, ap);
                if (lim > bufsize_init-1){
                    char f_tmp2[lim+1];
                    size_t nmemb = vsnprintf(f_tmp2,lim+1, format, ap);

                    ret = (int) FIT::Original.fwrite_((void*) f_tmp2, sizeof(char), 1, stream);
                    
                    if (ret > 0){
                        FIT::Original.logFile->log_output_clx(target_fd,(void*) f_tmp2, sizeof(char), ret);
                    }
                } else {
                    ret = (int) FIT::Original.fwrite_((void*) f_tmp, sizeof(char), 1, stream);
                    
                    if (ret > 0){
                        FIT::Original.logFile->log_output_clx(target_fd,(void*) f_tmp, sizeof(char), ret);
                    }
                }
                
                FIT::insideFIT = false;
                return ret;
    }
}

int (close)(int fd){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.close_ == NULL){
        FIT::Original.logFile->log_call("close loading error\n");
        __FIT__injectionFin();
        abort();
    }if (FIT::Original.logFile->isProtected(fd)){
        errno = EBADF;
        return -1;
    }
    if(FIT::insideFIT){
        
        return FIT::Original.close_(fd);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.close_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.close_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.close_(fd);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            
        }
        fire_flag = FIT::Original.close_flag - 1;
        FIT::Original.close_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("close ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("close\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (creat)(const char * pathname, mode_t mode){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.creat_ == NULL){
        FIT::Original.logFile->log_call("creat loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.creat_(pathname, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.creat_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * pathname_rec=pathname;
    static mode_t mode_rec=mode;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            pathname_rec==pathname&&
            mode_rec==mode&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.creat_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.creat_(pathname, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            pathname_rec=pathname;
            mode_rec=mode;
            
        }
        fire_flag = FIT::Original.creat_flag - 1;
        FIT::Original.creat_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("creat ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("creat\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return -1;
    }
}

int (creat64)(const char * pathname, mode_t mode){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.creat64_ == NULL){
        FIT::Original.logFile->log_call("creat64 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.creat64_(pathname, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.creat64_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * pathname_rec=pathname;
    static mode_t mode_rec=mode;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            pathname_rec==pathname&&
            mode_rec==mode&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.creat64_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.creat64_(pathname, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            pathname_rec=pathname;
            mode_rec=mode;
            
        }
        fire_flag = FIT::Original.creat64_flag - 1;
        FIT::Original.creat64_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("creat64 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("creat64\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return -1;
    }
}

int (fclose)(FILE * fp){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fclose_ == NULL){
        FIT::Original.logFile->log_call("fclose loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fclose_(fp);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fclose_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static FILE * fp_rec=fp;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fp_rec==fp&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fclose_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.fclose_(fp);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fp_rec=fp;
            
        }
        fire_flag = FIT::Original.fclose_flag - 1;
        FIT::Original.fclose_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fclose ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fclose\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return EOF;
    }
}

int (fcloseall)(){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fcloseall_ == NULL){
        FIT::Original.logFile->log_call("fcloseall loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fcloseall_();
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fcloseall_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fcloseall_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.fcloseall_();
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            
        }
        fire_flag = FIT::Original.fcloseall_flag - 1;
        FIT::Original.fcloseall_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fcloseall ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fcloseall\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return -1;
    }
}

int (fgetc)(FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fgetc_ == NULL){
        FIT::Original.logFile->log_call("fgetc loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fgetc_(stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fgetc_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fgetc_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                int ret = FIT::Original.fgetc_(stream);
                if (ret!=-1) {
                    FIT::Original.logFile->log_input_c(ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.fgetc_flag - 1;
        FIT::Original.fgetc_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fgetc ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fgetc\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return -1;
    }
}

char * (fgets)(char * s, int size, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fgets_ == NULL){
        FIT::Original.logFile->log_call("fgets loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fgets_(s, size, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fgets_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static char * s_rec=s;
    static int size_rec=size;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            s_rec==s&&
            size_rec==size&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fgets_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                char * ret = FIT::Original.fgets_(s, size, stream);
                if (ret!=NULL){
                    FIT::Original.logFile->log_input_str(s, size);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            s_rec=s;
            size_rec=size;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.fgets_flag - 1;
        FIT::Original.fgets_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fgets ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fgets\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return NULL;
    }
}

FILE * (fopen)(const char * path, const char * mode){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fopen_ == NULL){
        FIT::Original.logFile->log_call("fopen loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fopen_(path, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fopen_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * path_rec=path;
    static const char * mode_rec=mode;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            path_rec==path&&
            mode_rec==mode&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fopen_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.fopen_(path, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            path_rec=path;
            mode_rec=mode;
            
        }
        fire_flag = FIT::Original.fopen_flag - 1;
        FIT::Original.fopen_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fopen ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fopen\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return NULL;
    }
}

FILE * (fopen64)(const char * path, const char * mode){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fopen64_ == NULL){
        FIT::Original.logFile->log_call("fopen64 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fopen64_(path, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fopen64_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * path_rec=path;
    static const char * mode_rec=mode;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            path_rec==path&&
            mode_rec==mode&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fopen64_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.fopen64_(path, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            path_rec=path;
            mode_rec=mode;
            
        }
        fire_flag = FIT::Original.fopen64_flag - 1;
        FIT::Original.fopen64_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fopen64 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fopen64\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return NULL;
    }
}

int (fputc)(int c, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fputc_ == NULL){
        FIT::Original.logFile->log_call("fputc loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fputc_(c, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fputc_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int c_rec=c;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            c_rec==c&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fputc_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				

                int target_fd = fileno(stream);
                int ret = FIT::Original.fputc_(c, stream);
                if (ret==c) {
                    FIT::Original.logFile->log_output_c(target_fd, c);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            c_rec=c;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.fputc_flag - 1;
        FIT::Original.fputc_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fputc ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fputc\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return EOF;
    }
}

int (fputs)(const char * s, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fputs_ == NULL){
        FIT::Original.logFile->log_call("fputs loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fputs_(s, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fputs_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * s_rec=s;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            s_rec==s&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fputs_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                int target_fd = fileno(stream);
                int ret = FIT::Original.fputs_(s, stream);
                if (ret>=0){
                    FIT::Original.logFile->log_output_str(target_fd, s, ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            s_rec=s;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.fputs_flag - 1;
        FIT::Original.fputs_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fputs ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fputs\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return EOF;
    }
}

size_t (fread)(void * ptr, size_t size, size_t nb, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fread_ == NULL){
        FIT::Original.logFile->log_call("fread loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fread_(ptr, size, nb, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fread_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static void * ptr_rec=ptr;
    static size_t size_rec=size;
    static size_t nb_rec=nb;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            /*fxxfxxf*/ ptr_rec==(const void*)((const char*)ptr-size/sizeof(char))&&
            size_rec==size&&
            /*fxxfxxe*/ nb_rec==nb-1&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fread_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                size_t ret = FIT::Original.fread_(ptr, size, nb, stream);
                if (ret>=0){
                    FIT::Original.logFile->log_input_clx(ptr, size, ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            ptr_rec=ptr;
            size_rec=size;
            nb_rec=nb;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.fread_flag - 1;
        FIT::Original.fread_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fread ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fread\n");
        }
                

                size_t ret = FIT::Original.fread_(ptr, size, 1, stream);
                if (ret>0){
                    FIT::Original.logFile->log_input_clx(ptr, size, ret);
                }

                
                FIT::insideFIT = false;
                return ret;
    }
}

FILE * (freopen)(const char * path, const char * mode, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.freopen_ == NULL){
        FIT::Original.logFile->log_call("freopen loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.freopen_(path, mode, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.freopen_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * path_rec=path;
    static const char * mode_rec=mode;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            path_rec==path&&
            mode_rec==mode&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.freopen_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.freopen_(path, mode, stream);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            path_rec=path;
            mode_rec=mode;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.freopen_flag - 1;
        FIT::Original.freopen_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("freopen ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("freopen\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return NULL;
    }
}

FILE * (freopen64)(const char * filename, const char * type, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.freopen64_ == NULL){
        FIT::Original.logFile->log_call("freopen64 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.freopen64_(filename, type, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.freopen64_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * filename_rec=filename;
    static const char * type_rec=type;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            filename_rec==filename&&
            type_rec==type&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.freopen64_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.freopen64_(filename, type, stream);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            filename_rec=filename;
            type_rec=type;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.freopen64_flag - 1;
        FIT::Original.freopen64_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("freopen64 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("freopen64\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return NULL;
    }
}

size_t (fwrite)(const void * ptr, size_t size, size_t nb, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fwrite_ == NULL){
        FIT::Original.logFile->log_call("fwrite loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fwrite_(ptr, size, nb, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fwrite_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const void * ptr_rec=ptr;
    static size_t size_rec=size;
    static size_t nb_rec=nb;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            /*fxxfxxf*/ ptr_rec==(const void*)((const char*)ptr-size/sizeof(char))&&
            size_rec==size&&
            /*fxxfxxe*/ nb_rec==nb-1&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fwrite_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                int target_fd = fileno(stream);
                size_t ret = FIT::Original.fwrite_(ptr, size, nb, stream);
                if (ret>=0){
                    FIT::Original.logFile->log_output_clx(target_fd, ptr, size, ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            ptr_rec=ptr;
            size_rec=size;
            nb_rec=nb;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.fwrite_flag - 1;
        FIT::Original.fwrite_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fwrite ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fwrite\n");
        }
                

                int target_fd = fileno(stream);
                size_t ret = FIT::Original.fwrite_(ptr, size, 1, stream);
                if (ret>0){
                    FIT::Original.logFile->log_output_clx(target_fd, ptr, size, ret);
                }

                
                FIT::insideFIT = false;
                return ret;
    }
}

int (getc)(FILE * stream){
    return fgetc(stream);
    
}

int (getchar)(){
    return fgetc(stdin);
    
}

__ssize_t (getline)(char ** lineptr, size_t * n, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.getline_ == NULL){
        FIT::Original.logFile->log_call("getline loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.getline_(lineptr, n, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.getline_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static char ** lineptr_rec=lineptr;
    static size_t * n_rec=n;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            lineptr_rec==lineptr&&
            n_rec==n&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.getline_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                __ssize_t ret = FIT::Original.getline_(lineptr, n, stream);
                if (ret>=0){
                    FIT::Original.logFile->log_input_clx((void*) *lineptr, sizeof(char), ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            lineptr_rec=lineptr;
            n_rec=n;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.getline_flag - 1;
        FIT::Original.getline_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("getline ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("getline\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return -1;
    }
}

int (putc)(int c, FILE * stream){
    return fputc(c, stream);
    
}

int (putchar)(int c){
    return fputc(c, stdout);
    
}

int (puts)(const char * s){
    return fputs(s, stdout);
    
}

ssize_t (pread)(int fd, void * ptr, size_t nb, off_t offset){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.pread_ == NULL){
        FIT::Original.logFile->log_call("pread loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.pread_(fd, ptr, nb, offset);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.pread_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static void * ptr_rec=ptr;
    static size_t nb_rec=nb;
    static off_t offset_rec=offset;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            /*fxxfxxf*/ ptr_rec==(const void*)((const char*)ptr-sizeof(char))&&
            /*fxxfxxe*/ nb_rec==nb-1&&
            offset_rec==offset&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.pread_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                ssize_t ret = FIT::Original.pread_(fd, ptr, nb, offset);
                if (ret>=0){
                    FIT::Original.logFile->log_input_clx(ptr, 1, ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            ptr_rec=ptr;
            nb_rec=nb;
            offset_rec=offset;
            
        }
        fire_flag = FIT::Original.pread_flag - 1;
        FIT::Original.pread_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("pread ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("pread\n");
        }
                

                ssize_t ret = FIT::Original.pread_(fd, ptr, 1, offset);
                if (ret>0){
                    FIT::Original.logFile->log_input_clx(ptr, 1, ret);
                }

                
                FIT::insideFIT = false;
                return ret;
    }
}

ssize_t (pwrite)(int fd, const void * ptr, size_t nb, off_t offset){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.pwrite_ == NULL){
        FIT::Original.logFile->log_call("pwrite loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.pwrite_(fd, ptr, nb, offset);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.pwrite_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static const void * ptr_rec=ptr;
    static size_t nb_rec=nb;
    static off_t offset_rec=offset;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            /*fxxfxxf*/ ptr_rec==(const void*)((const char*)ptr-sizeof(char))&&
            /*fxxfxxe*/ nb_rec==nb-1&&
            offset_rec==offset&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.pwrite_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                int target_fd = fd;
                ssize_t ret = FIT::Original.pwrite_(fd, ptr, nb, offset);
                if (ret>=0){
                    FIT::Original.logFile->log_output_clx(target_fd, ptr, 1, ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            ptr_rec=ptr;
            nb_rec=nb;
            offset_rec=offset;
            
        }
        fire_flag = FIT::Original.pwrite_flag - 1;
        FIT::Original.pwrite_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("pwrite ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("pwrite\n");
        }
                

                int target_fd = fd;
                ssize_t ret = FIT::Original.pwrite_(fd, ptr, 1, offset);
                if (ret>0){
                    FIT::Original.logFile->log_output_clx(target_fd, ptr, 1, ret);
                }

                
                FIT::insideFIT = false;
                return ret;
    }
}

ssize_t (read)(int fd, void * ptr, size_t nb){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.read_ == NULL){
        FIT::Original.logFile->log_call("read loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.read_(fd, ptr, nb);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.read_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static void * ptr_rec=ptr;
    static size_t nb_rec=nb;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            /*fxxfxxf*/ ptr_rec==(const void*)((const char*)ptr-sizeof(char))&&
            /*fxxfxxe*/ nb_rec==nb-1&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.read_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                ssize_t ret = FIT::Original.read_(fd, ptr, nb);
                if (ret>=0){
                    FIT::Original.logFile->log_input_clx(ptr, 1, ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            ptr_rec=ptr;
            nb_rec=nb;
            
        }
        fire_flag = FIT::Original.read_flag - 1;
        FIT::Original.read_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("read ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("read\n");
        }
                

                ssize_t ret = FIT::Original.read_(fd, ptr, 1);
                if (ret>0){
                    FIT::Original.logFile->log_input_clx(ptr, 1, ret);
                }

                
                FIT::insideFIT = false;
                return ret;
    }
}

int (vprintf)(const char * format, va_list ap){
    return vfprintf(stdout, format, ap);
    
}

int (vscanf)(const char * format, va_list ap){
    return vfscanf(stdin, format, ap);
    
}

ssize_t (write)(int fd, const void * ptr, size_t nb){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.write_ == NULL){
        FIT::Original.logFile->log_call("write loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.write_(fd, ptr, nb);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.write_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static const void * ptr_rec=ptr;
    static size_t nb_rec=nb;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            /*fxxfxxf*/ ptr_rec==(const void*)((const char*)ptr-sizeof(char))&&
            /*fxxfxxe*/ nb_rec==nb-1&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.write_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                ssize_t ret = FIT::Original.write_(fd, ptr, nb);
                if (ret>=0){
                    FIT::Original.logFile->log_input_clx(ptr, 1, ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            ptr_rec=ptr;
            nb_rec=nb;
            
        }
        fire_flag = FIT::Original.write_flag - 1;
        FIT::Original.write_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("write ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("write\n");
        }
                

                ssize_t ret = FIT::Original.write_(fd, ptr, 1);
                if (ret>0){
                    FIT::Original.logFile->log_input_clx(ptr, 1, ret);
                }

                
                FIT::insideFIT = false;
                return ret;
    }
}

int (getc_unlocked)(FILE * stream){
    return fgetc_unlocked(stream);
    
}

int (getchar_unlocked)(){
    return fgetc_unlocked(stdin);
    
}

int (putc_unlocked)(int c, FILE * stream){
    return fputc_unlocked(c, stream);
    
}

int (putchar_unlocked)(int c){
    return fputc_unlocked(c, stdin);
    
}

size_t (fread_unlocked)(void * ptr, size_t size, size_t nb, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fread_unlocked_ == NULL){
        FIT::Original.logFile->log_call("fread_unlocked loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fread_unlocked_(ptr, size, nb, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fread_unlocked_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static void * ptr_rec=ptr;
    static size_t size_rec=size;
    static size_t nb_rec=nb;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            /*fxxfxxf*/ ptr_rec==(const void*)((const char*)ptr-size/sizeof(char))&&
            size_rec==size&&
            /*fxxfxxe*/ nb_rec==nb-1&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fread_unlocked_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                size_t ret = FIT::Original.fread_unlocked_(ptr, size, nb, stream);
                if (ret>=0){
                    FIT::Original.logFile->log_input_clx(ptr, size, ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            ptr_rec=ptr;
            size_rec=size;
            nb_rec=nb;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.fread_unlocked_flag - 1;
        FIT::Original.fread_unlocked_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fread_unlocked ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fread_unlocked\n");
        }
                

                size_t ret = FIT::Original.fread_unlocked_(ptr, size, 1, stream);
                if (ret>0){
                    FIT::Original.logFile->log_input_clx(ptr, size, ret);
                }

                
                FIT::insideFIT = false;
                return ret;
    }
}

size_t (fwrite_unlocked)(const void * ptr, size_t size, size_t nb, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fwrite_unlocked_ == NULL){
        FIT::Original.logFile->log_call("fwrite_unlocked loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fwrite_unlocked_(ptr, size, nb, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fwrite_unlocked_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const void * ptr_rec=ptr;
    static size_t size_rec=size;
    static size_t nb_rec=nb;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            /*fxxfxxf*/ ptr_rec==(const void*)((const char*)ptr-size/sizeof(char))&&
            size_rec==size&&
            /*fxxfxxe*/ nb_rec==nb-1&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fwrite_unlocked_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                int target_fd = fileno(stream);
                size_t ret = FIT::Original.fwrite_unlocked_(ptr, size, nb, stream);
                if (ret>=0){
                    FIT::Original.logFile->log_output_clx(target_fd, ptr, size, ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            ptr_rec=ptr;
            size_rec=size;
            nb_rec=nb;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.fwrite_unlocked_flag - 1;
        FIT::Original.fwrite_unlocked_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fwrite_unlocked ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fwrite_unlocked\n");
        }
                

                int target_fd = fileno(stream);
                size_t ret = FIT::Original.fwrite_unlocked_(ptr, size, 1, stream);
                if (ret>0){
                    FIT::Original.logFile->log_output_clx(target_fd, ptr, size, ret);
                }

                
                FIT::insideFIT = false;
                return ret;
    }
}

char * (fgets_unlocked)(char * s, int n, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fgets_unlocked_ == NULL){
        FIT::Original.logFile->log_call("fgets_unlocked loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fgets_unlocked_(s, n, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fgets_unlocked_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static char * s_rec=s;
    static int n_rec=n;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            s_rec==s&&
            n_rec==n&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fgets_unlocked_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                char * ret = FIT::Original.fgets_unlocked_(s, n, stream);
                if (ret!=NULL){
                    FIT::Original.logFile->log_input_str(s, n);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            s_rec=s;
            n_rec=n;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.fgets_unlocked_flag - 1;
        FIT::Original.fgets_unlocked_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fgets_unlocked ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fgets_unlocked\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return NULL;
    }
}

int (fputs_unlocked)(const char * s, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fputs_unlocked_ == NULL){
        FIT::Original.logFile->log_call("fputs_unlocked loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fputs_unlocked_(s, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fputs_unlocked_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * s_rec=s;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            s_rec==s&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fputs_unlocked_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                int target_fd = fileno(stream);
                int ret = FIT::Original.fputs_unlocked_(s, stream);
                if (ret>=0){
                    FIT::Original.logFile->log_output_str(target_fd, s, ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            s_rec=s;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.fputs_unlocked_flag - 1;
        FIT::Original.fputs_unlocked_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fputs_unlocked ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fputs_unlocked\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return EOF;
    }
}

int (fseek)(FILE * stream, long offset, int whence){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fseek_ == NULL){
        FIT::Original.logFile->log_call("fseek loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fseek_(stream, offset, whence);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fseek_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static FILE * stream_rec=stream;
    static long offset_rec=offset;
    static int whence_rec=whence;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            stream_rec==stream&&
            offset_rec==offset&&
            whence_rec==whence&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fseek_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.fseek_(stream, offset, whence);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            stream_rec=stream;
            offset_rec=offset;
            whence_rec=whence;
            
        }
        fire_flag = FIT::Original.fseek_flag - 1;
        FIT::Original.fseek_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fseek ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fseek\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (fseeko)(FILE * stream, off_t offset, int whence){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fseeko_ == NULL){
        FIT::Original.logFile->log_call("fseeko loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fseeko_(stream, offset, whence);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fseeko_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static FILE * stream_rec=stream;
    static off_t offset_rec=offset;
    static int whence_rec=whence;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            stream_rec==stream&&
            offset_rec==offset&&
            whence_rec==whence&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fseeko_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.fseeko_(stream, offset, whence);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            stream_rec=stream;
            offset_rec=offset;
            whence_rec=whence;
            
        }
        fire_flag = FIT::Original.fseeko_flag - 1;
        FIT::Original.fseeko_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fseeko ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fseeko\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (fsetpos)(FILE * stream, const fpos_t * pos){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fsetpos_ == NULL){
        FIT::Original.logFile->log_call("fsetpos loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fsetpos_(stream, pos);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fsetpos_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static FILE * stream_rec=stream;
    static const fpos_t * pos_rec=pos;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            stream_rec==stream&&
            pos_rec==pos&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fsetpos_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.fsetpos_(stream, pos);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            stream_rec=stream;
            pos_rec=pos;
            
        }
        fire_flag = FIT::Original.fsetpos_flag - 1;
        FIT::Original.fsetpos_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fsetpos ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fsetpos\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (fsetpos64)(FILE * stream, const fpos64_t * pos){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fsetpos64_ == NULL){
        FIT::Original.logFile->log_call("fsetpos64 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fsetpos64_(stream, pos);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fsetpos64_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static FILE * stream_rec=stream;
    static const fpos64_t * pos_rec=pos;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            stream_rec==stream&&
            pos_rec==pos&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fsetpos64_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.fsetpos64_(stream, pos);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            stream_rec=stream;
            pos_rec=pos;
            
        }
        fire_flag = FIT::Original.fsetpos64_flag - 1;
        FIT::Original.fsetpos64_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fsetpos64 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fsetpos64\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

off_t (lseek)(int fd, off_t offset, int whence){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.lseek_ == NULL){
        FIT::Original.logFile->log_call("lseek loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.lseek_(fd, offset, whence);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.lseek_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static off_t offset_rec=offset;
    static int whence_rec=whence;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            offset_rec==offset&&
            whence_rec==whence&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.lseek_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.lseek_(fd, offset, whence);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            offset_rec=offset;
            whence_rec=whence;
            
        }
        fire_flag = FIT::Original.lseek_flag - 1;
        FIT::Original.lseek_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("lseek ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("lseek\n");
        }
        int errList[] = {EBADF,ESPIPE,EOVERFLOW,EINVAL};int errlen = 4;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return (off_t) -1;
    }
}

off64_t (lseek64)(int fd, off64_t offset, int whence){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.lseek64_ == NULL){
        FIT::Original.logFile->log_call("lseek64 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.lseek64_(fd, offset, whence);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.lseek64_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static off64_t offset_rec=offset;
    static int whence_rec=whence;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            offset_rec==offset&&
            whence_rec==whence&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.lseek64_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.lseek64_(fd, offset, whence);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            offset_rec=offset;
            whence_rec=whence;
            
        }
        fire_flag = FIT::Original.lseek64_flag - 1;
        FIT::Original.lseek64_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("lseek64 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("lseek64\n");
        }
        int errList[] = {EBADF,ESPIPE,EOVERFLOW,EINVAL};int errlen = 4;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return (off_t) -1;
    }
}

int (chmod)(const char * path, mode_t mode){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.chmod_ == NULL){
        FIT::Original.logFile->log_call("chmod loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.chmod_(path, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.chmod_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * path_rec=path;
    static mode_t mode_rec=mode;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            path_rec==path&&
            mode_rec==mode&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.chmod_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.chmod_(path, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            path_rec=path;
            mode_rec=mode;
            
        }
        fire_flag = FIT::Original.chmod_flag - 1;
        FIT::Original.chmod_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("chmod ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("chmod\n");
        }
        errno = EIO;
        FIT::insideFIT = false;
        return -1;
    }
}

int (chown)(const char * path, uid_t owner, gid_t group){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.chown_ == NULL){
        FIT::Original.logFile->log_call("chown loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.chown_(path, owner, group);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.chown_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * path_rec=path;
    static uid_t owner_rec=owner;
    static gid_t group_rec=group;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            path_rec==path&&
            owner_rec==owner&&
            group_rec==group&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.chown_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.chown_(path, owner, group);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            path_rec=path;
            owner_rec=owner;
            group_rec=group;
            
        }
        fire_flag = FIT::Original.chown_flag - 1;
        FIT::Original.chown_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("chown ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("chown\n");
        }
        errno = EIO;
        FIT::insideFIT = false;
        return -1;
    }
}

int (fchmod)(int fd, mode_t mode){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fchmod_ == NULL){
        FIT::Original.logFile->log_call("fchmod loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fchmod_(fd, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fchmod_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static mode_t mode_rec=mode;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            mode_rec==mode&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fchmod_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.fchmod_(fd, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            mode_rec=mode;
            
        }
        fire_flag = FIT::Original.fchmod_flag - 1;
        FIT::Original.fchmod_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fchmod ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fchmod\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (fchown)(int fd, uid_t owner, gid_t group){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fchown_ == NULL){
        FIT::Original.logFile->log_call("fchown loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fchown_(fd, owner, group);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fchown_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static uid_t owner_rec=owner;
    static gid_t group_rec=group;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            owner_rec==owner&&
            group_rec==group&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fchown_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.fchown_(fd, owner, group);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            owner_rec=owner;
            group_rec=group;
            
        }
        fire_flag = FIT::Original.fchown_flag - 1;
        FIT::Original.fchown_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fchown ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fchown\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (lchown)(const char * path, uid_t owner, gid_t group){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.lchown_ == NULL){
        FIT::Original.logFile->log_call("lchown loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.lchown_(path, owner, group);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.lchown_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * path_rec=path;
    static uid_t owner_rec=owner;
    static gid_t group_rec=group;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            path_rec==path&&
            owner_rec==owner&&
            group_rec==group&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.lchown_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.lchown_(path, owner, group);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            path_rec=path;
            owner_rec=owner;
            group_rec=group;
            
        }
        fire_flag = FIT::Original.lchown_flag - 1;
        FIT::Original.lchown_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("lchown ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("lchown\n");
        }
        errno = EIO;
        FIT::insideFIT = false;
        return -1;
    }
}

int (dup)(int oldfd){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.dup_ == NULL){
        FIT::Original.logFile->log_call("dup loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.dup_(oldfd);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.dup_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int oldfd_rec=oldfd;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            oldfd_rec==oldfd&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.dup_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.dup_(oldfd);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            oldfd_rec=oldfd;
            
        }
        fire_flag = FIT::Original.dup_flag - 1;
        FIT::Original.dup_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("dup ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("dup\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (dup2)(int oldfd, int newfd){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.dup2_ == NULL){
        FIT::Original.logFile->log_call("dup2 loading error\n");
        __FIT__injectionFin();
        abort();
    }if (FIT::Original.logFile->isProtected(newfd)){
        errno = EBADF;
        return -1;
    }
    if(FIT::insideFIT){
        
        return FIT::Original.dup2_(oldfd, newfd);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.dup2_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int oldfd_rec=oldfd;
    static int newfd_rec=newfd;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            oldfd_rec==oldfd&&
            newfd_rec==newfd&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.dup2_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.dup2_(oldfd, newfd);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            oldfd_rec=oldfd;
            newfd_rec=newfd;
            
        }
        fire_flag = FIT::Original.dup2_flag - 1;
        FIT::Original.dup2_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("dup2 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("dup2\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (dup3)(int oldfd, int newfd, int flags){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.dup3_ == NULL){
        FIT::Original.logFile->log_call("dup3 loading error\n");
        __FIT__injectionFin();
        abort();
    }if (FIT::Original.logFile->isProtected(newfd)){
        errno = EBADF;
        return -1;
    }
    if(FIT::insideFIT){
        
        return FIT::Original.dup3_(oldfd, newfd, flags);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.dup3_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int oldfd_rec=oldfd;
    static int newfd_rec=newfd;
    static int flags_rec=flags;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            oldfd_rec==oldfd&&
            newfd_rec==newfd&&
            flags_rec==flags&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.dup3_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.dup3_(oldfd, newfd, flags);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            oldfd_rec=oldfd;
            newfd_rec=newfd;
            flags_rec=flags;
            
        }
        fire_flag = FIT::Original.dup3_flag - 1;
        FIT::Original.dup3_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("dup3 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("dup3\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (ftruncate)(int fd, off_t length){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.ftruncate_ == NULL){
        FIT::Original.logFile->log_call("ftruncate loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.ftruncate_(fd, length);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.ftruncate_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static off_t length_rec=length;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            length_rec==length&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.ftruncate_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.ftruncate_(fd, length);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            length_rec=length;
            
        }
        fire_flag = FIT::Original.ftruncate_flag - 1;
        FIT::Original.ftruncate_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("ftruncate ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("ftruncate\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (ftruncate64)(int fd, off64_t length){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.ftruncate64_ == NULL){
        FIT::Original.logFile->log_call("ftruncate64 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.ftruncate64_(fd, length);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.ftruncate64_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static off64_t length_rec=length;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            length_rec==length&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.ftruncate64_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.ftruncate64_(fd, length);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            length_rec=length;
            
        }
        fire_flag = FIT::Original.ftruncate64_flag - 1;
        FIT::Original.ftruncate64_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("ftruncate64 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("ftruncate64\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (link)(const char * path1, const char * path2){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.link_ == NULL){
        FIT::Original.logFile->log_call("link loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.link_(path1, path2);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.link_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * path1_rec=path1;
    static const char * path2_rec=path2;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            path1_rec==path1&&
            path2_rec==path2&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.link_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.link_(path1, path2);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            path1_rec=path1;
            path2_rec=path2;
            
        }
        fire_flag = FIT::Original.link_flag - 1;
        FIT::Original.link_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("link ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("link\n");
        }
        errno = EIO;
        FIT::insideFIT = false;
        return -1;
    }
}

int (mkdir)(const char * pathname, mode_t mode){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.mkdir_ == NULL){
        FIT::Original.logFile->log_call("mkdir loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.mkdir_(pathname, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.mkdir_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * pathname_rec=pathname;
    static mode_t mode_rec=mode;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            pathname_rec==pathname&&
            mode_rec==mode&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.mkdir_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.mkdir_(pathname, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            pathname_rec=pathname;
            mode_rec=mode;
            
        }
        fire_flag = FIT::Original.mkdir_flag - 1;
        FIT::Original.mkdir_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("mkdir ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("mkdir\n");
        }
        int errList[] = {ELOOP,ENOTDIR,EMLINK,EACCES,EEXIST,ENOENT,ENAMETOOLONG,ENOSPC,EROFS};int errlen = 9;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (mkfifo)(const char * pathname, mode_t mode){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.mkfifo_ == NULL){
        FIT::Original.logFile->log_call("mkfifo loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.mkfifo_(pathname, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.mkfifo_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * pathname_rec=pathname;
    static mode_t mode_rec=mode;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            pathname_rec==pathname&&
            mode_rec==mode&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.mkfifo_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.mkfifo_(pathname, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            pathname_rec=pathname;
            mode_rec=mode;
            
        }
        fire_flag = FIT::Original.mkfifo_flag - 1;
        FIT::Original.mkfifo_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("mkfifo ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("mkfifo\n");
        }
        int errList[] = {ELOOP,ENOTDIR,EACCES,EDQUOT,ENAMETOOLONG,ENOENT,EEXIST,ENOSPC,EROFS};int errlen = 9;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (__xmknod)(int __ver, const char * pathname, mode_t mode, dev_t* dev){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__xmknod_ == NULL){
        FIT::Original.logFile->log_call("__xmknod loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__xmknod_(__ver, pathname, mode, dev);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__xmknod_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int __ver_rec=__ver;
    static const char * pathname_rec=pathname;
    static mode_t mode_rec=mode;
    static dev_t* dev_rec=dev;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            __ver_rec==__ver&&
            pathname_rec==pathname&&
            mode_rec==mode&&
            dev_rec==dev&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__xmknod_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.__xmknod_(__ver, pathname, mode, dev);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            __ver_rec=__ver;
            pathname_rec=pathname;
            mode_rec=mode;
            dev_rec=dev;
            
        }
        fire_flag = FIT::Original.__xmknod_flag - 1;
        FIT::Original.__xmknod_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__xmknod ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__xmknod\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (remove)(const char * pathname){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.remove_ == NULL){
        FIT::Original.logFile->log_call("remove loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.remove_(pathname);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.remove_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * pathname_rec=pathname;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            pathname_rec==pathname&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.remove_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.remove_(pathname);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            pathname_rec=pathname;
            
        }
        fire_flag = FIT::Original.remove_flag - 1;
        FIT::Original.remove_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("remove ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("remove\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (rename)(const char * oldpath, const char * newpath){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.rename_ == NULL){
        FIT::Original.logFile->log_call("rename loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.rename_(oldpath, newpath);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.rename_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * oldpath_rec=oldpath;
    static const char * newpath_rec=newpath;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            oldpath_rec==oldpath&&
            newpath_rec==newpath&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.rename_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.rename_(oldpath, newpath);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            oldpath_rec=oldpath;
            newpath_rec=newpath;
            
        }
        fire_flag = FIT::Original.rename_flag - 1;
        FIT::Original.rename_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("rename ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("rename\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (rmdir)(const char * pathname){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.rmdir_ == NULL){
        FIT::Original.logFile->log_call("rmdir loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.rmdir_(pathname);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.rmdir_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * pathname_rec=pathname;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            pathname_rec==pathname&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.rmdir_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.rmdir_(pathname);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            pathname_rec=pathname;
            
        }
        fire_flag = FIT::Original.rmdir_flag - 1;
        FIT::Original.rmdir_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("rmdir ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("rmdir\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (symlink)(const char * oldpath, const char * newpath){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.symlink_ == NULL){
        FIT::Original.logFile->log_call("symlink loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.symlink_(oldpath, newpath);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.symlink_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * oldpath_rec=oldpath;
    static const char * newpath_rec=newpath;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            oldpath_rec==oldpath&&
            newpath_rec==newpath&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.symlink_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.symlink_(oldpath, newpath);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            oldpath_rec=oldpath;
            newpath_rec=newpath;
            
        }
        fire_flag = FIT::Original.symlink_flag - 1;
        FIT::Original.symlink_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("symlink ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("symlink\n");
        }
        errno = EIO;
        FIT::insideFIT = false;
        return -1;
    }
}

int (truncate)(const char * path, off_t length){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.truncate_ == NULL){
        FIT::Original.logFile->log_call("truncate loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.truncate_(path, length);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.truncate_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * path_rec=path;
    static off_t length_rec=length;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            path_rec==path&&
            length_rec==length&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.truncate_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.truncate_(path, length);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            path_rec=path;
            length_rec=length;
            
        }
        fire_flag = FIT::Original.truncate_flag - 1;
        FIT::Original.truncate_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("truncate ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("truncate\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (truncate64)(const char * path, off64_t length){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.truncate64_ == NULL){
        FIT::Original.logFile->log_call("truncate64 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.truncate64_(path, length);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.truncate64_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * path_rec=path;
    static off64_t length_rec=length;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            path_rec==path&&
            length_rec==length&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.truncate64_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.truncate64_(path, length);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            path_rec=path;
            length_rec=length;
            
        }
        fire_flag = FIT::Original.truncate64_flag - 1;
        FIT::Original.truncate64_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("truncate64 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("truncate64\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (unlink)(const char * pathname){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.unlink_ == NULL){
        FIT::Original.logFile->log_call("unlink loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.unlink_(pathname);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.unlink_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * pathname_rec=pathname;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            pathname_rec==pathname&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.unlink_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.unlink_(pathname);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            pathname_rec=pathname;
            
        }
        fire_flag = FIT::Original.unlink_flag - 1;
        FIT::Original.unlink_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("unlink ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("unlink\n");
        }
        int errList[] = {EBADF,ELOOP,ETXTBSY,ENOTDIR,ENOTEMPTY,EACCES,EBUSY,ENAMETOOLONG,ENOENT,EEXIST,EROFS,EINVAL};int errlen = 12;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

FILE * (popen)(const char * command, const char * type){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.popen_ == NULL){
        FIT::Original.logFile->log_call("popen loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.popen_(command, type);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.popen_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * command_rec=command;
    static const char * type_rec=type;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            command_rec==command&&
            type_rec==type&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.popen_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.popen_(command, type);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            command_rec=command;
            type_rec=type;
            
        }
        fire_flag = FIT::Original.popen_flag - 1;
        FIT::Original.popen_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("popen ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("popen\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return NULL;
    }
}

int (pclose)(FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.pclose_ == NULL){
        FIT::Original.logFile->log_call("pclose loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.pclose_(stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.pclose_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.pclose_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.pclose_(stream);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.pclose_flag - 1;
        FIT::Original.pclose_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("pclose ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("pclose\n");
        }
        int errList[] = {ECHILD};int errlen = 1;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (mkstemp)(char * templ){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.mkstemp_ == NULL){
        FIT::Original.logFile->log_call("mkstemp loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.mkstemp_(templ);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.mkstemp_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static char * templ_rec=templ;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            templ_rec==templ&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.mkstemp_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.mkstemp_(templ);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            templ_rec=templ;
            
        }
        fire_flag = FIT::Original.mkstemp_flag - 1;
        FIT::Original.mkstemp_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("mkstemp ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("mkstemp\n");
        }
        int errList[] = {EEXIST,EINVAL};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (mkostemp)(char * templ, int flags){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.mkostemp_ == NULL){
        FIT::Original.logFile->log_call("mkostemp loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.mkostemp_(templ, flags);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.mkostemp_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static char * templ_rec=templ;
    static int flags_rec=flags;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            templ_rec==templ&&
            flags_rec==flags&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.mkostemp_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.mkostemp_(templ, flags);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            templ_rec=templ;
            flags_rec=flags;
            
        }
        fire_flag = FIT::Original.mkostemp_flag - 1;
        FIT::Original.mkostemp_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("mkostemp ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("mkostemp\n");
        }
        int errList[] = {EEXIST,EINVAL};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (mkstemps)(char * templ, int suffixlen){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.mkstemps_ == NULL){
        FIT::Original.logFile->log_call("mkstemps loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.mkstemps_(templ, suffixlen);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.mkstemps_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static char * templ_rec=templ;
    static int suffixlen_rec=suffixlen;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            templ_rec==templ&&
            suffixlen_rec==suffixlen&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.mkstemps_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.mkstemps_(templ, suffixlen);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            templ_rec=templ;
            suffixlen_rec=suffixlen;
            
        }
        fire_flag = FIT::Original.mkstemps_flag - 1;
        FIT::Original.mkstemps_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("mkstemps ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("mkstemps\n");
        }
        int errList[] = {EEXIST,EINVAL};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (mkostemps)(char * templ, int suffixlen, int flags){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.mkostemps_ == NULL){
        FIT::Original.logFile->log_call("mkostemps loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.mkostemps_(templ, suffixlen, flags);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.mkostemps_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static char * templ_rec=templ;
    static int suffixlen_rec=suffixlen;
    static int flags_rec=flags;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            templ_rec==templ&&
            suffixlen_rec==suffixlen&&
            flags_rec==flags&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.mkostemps_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.mkostemps_(templ, suffixlen, flags);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            templ_rec=templ;
            suffixlen_rec=suffixlen;
            flags_rec=flags;
            
        }
        fire_flag = FIT::Original.mkostemps_flag - 1;
        FIT::Original.mkostemps_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("mkostemps ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("mkostemps\n");
        }
        int errList[] = {EEXIST,EINVAL};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

FILE * (tmpfile)(){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.tmpfile_ == NULL){
        FIT::Original.logFile->log_call("tmpfile loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.tmpfile_();
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.tmpfile_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.tmpfile_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.tmpfile_();
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            
        }
        fire_flag = FIT::Original.tmpfile_flag - 1;
        FIT::Original.tmpfile_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("tmpfile ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("tmpfile\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return NULL;
    }
}

FILE * (tmpfile64)(){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.tmpfile64_ == NULL){
        FIT::Original.logFile->log_call("tmpfile64 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.tmpfile64_();
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.tmpfile64_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.tmpfile64_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.tmpfile64_();
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            
        }
        fire_flag = FIT::Original.tmpfile64_flag - 1;
        FIT::Original.tmpfile64_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("tmpfile64 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("tmpfile64\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return NULL;
    }
}

int (__fxstat)(int __ver, int fd, struct stat * buf){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__fxstat_ == NULL){
        FIT::Original.logFile->log_call("__fxstat loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__fxstat_(__ver, fd, buf);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__fxstat_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int __ver_rec=__ver;
    static int fd_rec=fd;
    static struct stat * buf_rec=buf;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            __ver_rec==__ver&&
            fd_rec==fd&&
            buf_rec==buf&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__fxstat_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.__fxstat_(__ver, fd, buf);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            __ver_rec=__ver;
            fd_rec=fd;
            buf_rec=buf;
            
        }
        fire_flag = FIT::Original.__fxstat_flag - 1;
        FIT::Original.__fxstat_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__fxstat ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__fxstat\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (__fxstat64)(int __ver, int fd, struct stat64 * buf){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__fxstat64_ == NULL){
        FIT::Original.logFile->log_call("__fxstat64 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__fxstat64_(__ver, fd, buf);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__fxstat64_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int __ver_rec=__ver;
    static int fd_rec=fd;
    static struct stat64 * buf_rec=buf;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            __ver_rec==__ver&&
            fd_rec==fd&&
            buf_rec==buf&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__fxstat64_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.__fxstat64_(__ver, fd, buf);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            __ver_rec=__ver;
            fd_rec=fd;
            buf_rec=buf;
            
        }
        fire_flag = FIT::Original.__fxstat64_flag - 1;
        FIT::Original.__fxstat64_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__fxstat64 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__fxstat64\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (__lxstat)(int __ver, const char * path, struct stat * buf){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__lxstat_ == NULL){
        FIT::Original.logFile->log_call("__lxstat loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__lxstat_(__ver, path, buf);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__lxstat_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int __ver_rec=__ver;
    static const char * path_rec=path;
    static struct stat * buf_rec=buf;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            __ver_rec==__ver&&
            path_rec==path&&
            buf_rec==buf&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__lxstat_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.__lxstat_(__ver, path, buf);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            __ver_rec=__ver;
            path_rec=path;
            buf_rec=buf;
            
        }
        fire_flag = FIT::Original.__lxstat_flag - 1;
        FIT::Original.__lxstat_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__lxstat ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__lxstat\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (__lxstat64)(int __ver, const char * path, struct stat64 * buf){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__lxstat64_ == NULL){
        FIT::Original.logFile->log_call("__lxstat64 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__lxstat64_(__ver, path, buf);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__lxstat64_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int __ver_rec=__ver;
    static const char * path_rec=path;
    static struct stat64 * buf_rec=buf;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            __ver_rec==__ver&&
            path_rec==path&&
            buf_rec==buf&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__lxstat64_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.__lxstat64_(__ver, path, buf);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            __ver_rec=__ver;
            path_rec=path;
            buf_rec=buf;
            
        }
        fire_flag = FIT::Original.__lxstat64_flag - 1;
        FIT::Original.__lxstat64_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__lxstat64 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__lxstat64\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (__xstat)(int __ver, const char * path, struct stat * buf){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__xstat_ == NULL){
        FIT::Original.logFile->log_call("__xstat loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__xstat_(__ver, path, buf);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__xstat_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int __ver_rec=__ver;
    static const char * path_rec=path;
    static struct stat * buf_rec=buf;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            __ver_rec==__ver&&
            path_rec==path&&
            buf_rec==buf&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__xstat_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.__xstat_(__ver, path, buf);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            __ver_rec=__ver;
            path_rec=path;
            buf_rec=buf;
            
        }
        fire_flag = FIT::Original.__xstat_flag - 1;
        FIT::Original.__xstat_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__xstat ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__xstat\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (__xstat64)(int __ver, const char * path, struct stat64 * buf){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__xstat64_ == NULL){
        FIT::Original.logFile->log_call("__xstat64 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__xstat64_(__ver, path, buf);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__xstat64_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int __ver_rec=__ver;
    static const char * path_rec=path;
    static struct stat64 * buf_rec=buf;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            __ver_rec==__ver&&
            path_rec==path&&
            buf_rec==buf&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__xstat64_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.__xstat64_(__ver, path, buf);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            __ver_rec=__ver;
            path_rec=path;
            buf_rec=buf;
            
        }
        fire_flag = FIT::Original.__xstat64_flag - 1;
        FIT::Original.__xstat64_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__xstat64 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__xstat64\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (chdir)(const char * path){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.chdir_ == NULL){
        FIT::Original.logFile->log_call("chdir loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.chdir_(path);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.chdir_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * path_rec=path;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            path_rec==path&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.chdir_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.chdir_(path);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            path_rec=path;
            
        }
        fire_flag = FIT::Original.chdir_flag - 1;
        FIT::Original.chdir_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("chdir ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("chdir\n");
        }
        int errList[] = {EACCES,ENAMETOOLONG,ELOOP,ENOTDIR,ENOENT};int errlen = 5;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (fchdir)(int fd){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fchdir_ == NULL){
        FIT::Original.logFile->log_call("fchdir loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fchdir_(fd);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fchdir_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fchdir_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.fchdir_(fd);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            
        }
        fire_flag = FIT::Original.fchdir_flag - 1;
        FIT::Original.fchdir_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fchdir ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fchdir\n");
        }
        errno = EIO;
        FIT::insideFIT = false;
        return -1;
    }
}

int (killpg)(int pgrp, int sig){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.killpg_ == NULL){
        FIT::Original.logFile->log_call("killpg loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.killpg_(pgrp, sig);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.killpg_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int pgrp_rec=pgrp;
    static int sig_rec=sig;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            pgrp_rec==pgrp&&
            sig_rec==sig&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.killpg_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.killpg_(pgrp, sig);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            pgrp_rec=pgrp;
            sig_rec=sig;
            
        }
        fire_flag = FIT::Original.killpg_flag - 1;
        FIT::Original.killpg_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("killpg ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("killpg\n");
        }
        int errList[] = {ESRCH,EPERM,EINVAL};int errlen = 3;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (seteuid)(uid_t euid){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.seteuid_ == NULL){
        FIT::Original.logFile->log_call("seteuid loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.seteuid_(euid);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.seteuid_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static uid_t euid_rec=euid;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            euid_rec==euid&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.seteuid_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.seteuid_(euid);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            euid_rec=euid;
            
        }
        fire_flag = FIT::Original.seteuid_flag - 1;
        FIT::Original.seteuid_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("seteuid ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("seteuid\n");
        }
        int errList[] = {EPERM,EINVAL};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (setegid)(gid_t egid){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.setegid_ == NULL){
        FIT::Original.logFile->log_call("setegid loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.setegid_(egid);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.setegid_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static gid_t egid_rec=egid;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            egid_rec==egid&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.setegid_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.setegid_(egid);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            egid_rec=egid;
            
        }
        fire_flag = FIT::Original.setegid_flag - 1;
        FIT::Original.setegid_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("setegid ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("setegid\n");
        }
        int errList[] = {EPERM,EINVAL};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (setgid)(gid_t gid){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.setgid_ == NULL){
        FIT::Original.logFile->log_call("setgid loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.setgid_(gid);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.setgid_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static gid_t gid_rec=gid;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            gid_rec==gid&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.setgid_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.setgid_(gid);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            gid_rec=gid;
            
        }
        fire_flag = FIT::Original.setgid_flag - 1;
        FIT::Original.setgid_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("setgid ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("setgid\n");
        }
        int errList[] = {EPERM,EINVAL};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (setreuid)(uid_t ruid, uid_t euid){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.setreuid_ == NULL){
        FIT::Original.logFile->log_call("setreuid loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.setreuid_(ruid, euid);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.setreuid_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static uid_t ruid_rec=ruid;
    static uid_t euid_rec=euid;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            ruid_rec==ruid&&
            euid_rec==euid&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.setreuid_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.setreuid_(ruid, euid);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            ruid_rec=ruid;
            euid_rec=euid;
            
        }
        fire_flag = FIT::Original.setreuid_flag - 1;
        FIT::Original.setreuid_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("setreuid ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("setreuid\n");
        }
        int errList[] = {EPERM,EINVAL};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (setregid)(gid_t rgid, gid_t egid){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.setregid_ == NULL){
        FIT::Original.logFile->log_call("setregid loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.setregid_(rgid, egid);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.setregid_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static gid_t rgid_rec=rgid;
    static gid_t egid_rec=egid;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            rgid_rec==rgid&&
            egid_rec==egid&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.setregid_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.setregid_(rgid, egid);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            rgid_rec=rgid;
            egid_rec=egid;
            
        }
        fire_flag = FIT::Original.setregid_flag - 1;
        FIT::Original.setregid_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("setregid ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("setregid\n");
        }
        int errList[] = {EPERM,EINVAL};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (setuid)(uid_t uid){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.setuid_ == NULL){
        FIT::Original.logFile->log_call("setuid loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.setuid_(uid);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.setuid_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static uid_t uid_rec=uid;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            uid_rec==uid&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.setuid_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.setuid_(uid);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            uid_rec=uid;
            
        }
        fire_flag = FIT::Original.setuid_flag - 1;
        FIT::Original.setuid_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("setuid ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("setuid\n");
        }
        int errList[] = {EPERM,EINVAL};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (clearenv)(){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.clearenv_ == NULL){
        FIT::Original.logFile->log_call("clearenv loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.clearenv_();
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.clearenv_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.clearenv_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.clearenv_();
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            
        }
        fire_flag = FIT::Original.clearenv_flag - 1;
        FIT::Original.clearenv_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("clearenv ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("clearenv\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (putenv)(char * string){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.putenv_ == NULL){
        FIT::Original.logFile->log_call("putenv loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.putenv_(string);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.putenv_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static char * string_rec=string;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            string_rec==string&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.putenv_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.putenv_(string);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            string_rec=string;
            
        }
        fire_flag = FIT::Original.putenv_flag - 1;
        FIT::Original.putenv_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("putenv ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("putenv\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (setenv)(const char * name, const char * value, int overwrite){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.setenv_ == NULL){
        FIT::Original.logFile->log_call("setenv loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.setenv_(name, value, overwrite);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.setenv_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * name_rec=name;
    static const char * value_rec=value;
    static int overwrite_rec=overwrite;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            name_rec==name&&
            value_rec==value&&
            overwrite_rec==overwrite&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.setenv_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.setenv_(name, value, overwrite);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            name_rec=name;
            value_rec=value;
            overwrite_rec=overwrite;
            
        }
        fire_flag = FIT::Original.setenv_flag - 1;
        FIT::Original.setenv_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("setenv ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("setenv\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (unsetenv)(const char * name){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.unsetenv_ == NULL){
        FIT::Original.logFile->log_call("unsetenv loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.unsetenv_(name);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.unsetenv_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * name_rec=name;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            name_rec==name&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.unsetenv_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.unsetenv_(name);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            name_rec=name;
            
        }
        fire_flag = FIT::Original.unsetenv_flag - 1;
        FIT::Original.unsetenv_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("unsetenv ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("unsetenv\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (open)(const char *pathname, int flags, ...){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.open_ == NULL){
        FIT::Original.logFile->log_call("open loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        mode_t mode = 0;
        if ((flags & O_CREAT) != 0)
        {
            va_list arg;
            va_start(arg, flags);
            mode = va_arg(arg, mode_t);
            va_end(arg);
        }
        return FIT::Original.open_( pathname, flags, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.open_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    /*00AA00:*/ static const char *pathname_rec=pathname;
static int flags_rec=flags;

    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            /*00AA00:*/ pathname_rec==pathname&&
flags_rec==flags&&

            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.open_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        mode_t mode = 0;
        if ((flags & O_CREAT) != 0)
        {
            va_list arg;
            va_start(arg, flags);
            mode = va_arg(arg, mode_t);
            va_end(arg);
        }
        return FIT::Original.open_( pathname, flags, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            
            /*00AA00:*/ pathname_rec=pathname;
flags_rec=flags;

            
        }
        fire_flag = FIT::Original.open_flag - 1;
        FIT::Original.open_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("open ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("open\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return -1;
    }
}

int (open64)(const char *pathname, int flags, ...){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.open64_ == NULL){
        FIT::Original.logFile->log_call("open64 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        mode_t mode = 0;
        if ((flags & O_CREAT) != 0)
        {
            va_list arg;
            va_start(arg, flags);
            mode = va_arg(arg, mode_t);
            va_end(arg);
        }
        return FIT::Original.open64_( pathname, flags, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.open64_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    /*00AA00:*/ static const char *pathname_rec=pathname;
static int flags_rec=flags;

    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            /*00AA00:*/ pathname_rec==pathname&&
flags_rec==flags&&

            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.open64_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        mode_t mode = 0;
        if ((flags & O_CREAT) != 0)
        {
            va_list arg;
            va_start(arg, flags);
            mode = va_arg(arg, mode_t);
            va_end(arg);
        }
        return FIT::Original.open64_( pathname, flags, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            
            /*00AA00:*/ pathname_rec=pathname;
flags_rec=flags;

            
        }
        fire_flag = FIT::Original.open64_flag - 1;
        FIT::Original.open64_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("open64 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("open64\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return -1;
    }
}

int (printf)(const char * format, ...){
    va_list va_args;
        va_start(va_args, format);int _rtn = vprintf(format, va_args);
        va_end(va_args);
        return _rtn;
}

int (scanf)(const char * format, ...){
    va_list va_args;
        va_start(va_args, format);int _rtn = vscanf(format, va_args);
        va_end(va_args);
        return _rtn;
}

int (fprintf)(FILE * stream, const char * format, ...){
    va_list va_args;
        va_start(va_args, format);int _rtn = vfprintf(stream, format, va_args);
        va_end(va_args);
        return _rtn;
}

int (dprintf)(int fd, const char * format, ...){
    va_list va_args;
        va_start(va_args, format);int _rtn = vdprintf(fd, format, va_args);
        va_end(va_args);
        return _rtn;
}

int (fscanf)(FILE * stream, const char * format, ...){
    va_list va_args;
        va_start(va_args, format);int _rtn = vfscanf(stream, format, va_args);
        va_end(va_args);
        return _rtn;
}

int (socket)(int domain, int type, int protocol){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.socket_ == NULL){
        FIT::Original.logFile->log_call("socket loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.socket_(domain, type, protocol);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.socket_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int domain_rec=domain;
    static int type_rec=type;
    static int protocol_rec=protocol;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            domain_rec==domain&&
            type_rec==type&&
            protocol_rec==protocol&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.socket_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.socket_(domain, type, protocol);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            domain_rec=domain;
            type_rec=type;
            protocol_rec=protocol;
            
        }
        fire_flag = FIT::Original.socket_flag - 1;
        FIT::Original.socket_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("socket ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("socket\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (accept)(int sockfd, struct sockaddr * addr, socklen_t * addrlen){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.accept_ == NULL){
        FIT::Original.logFile->log_call("accept loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.accept_(sockfd, addr, addrlen);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.accept_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int sockfd_rec=sockfd;
    static struct sockaddr * addr_rec=addr;
    static socklen_t * addrlen_rec=addrlen;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            sockfd_rec==sockfd&&
            addr_rec==addr&&
            addrlen_rec==addrlen&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.accept_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.accept_(sockfd, addr, addrlen);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            sockfd_rec=sockfd;
            addr_rec=addr;
            addrlen_rec=addrlen;
            
        }
        fire_flag = FIT::Original.accept_flag - 1;
        FIT::Original.accept_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("accept ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("accept\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return -1;
    }
}

int (pipe)(int * pipefd){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.pipe_ == NULL){
        FIT::Original.logFile->log_call("pipe loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.pipe_(pipefd);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.pipe_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int * pipefd_rec=pipefd;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            pipefd_rec==pipefd&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.pipe_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.pipe_(pipefd);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            pipefd_rec=pipefd;
            
        }
        fire_flag = FIT::Original.pipe_flag - 1;
        FIT::Original.pipe_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("pipe ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("pipe\n");
        }
        int errList[] = {ENFILE,EFAULT,EMFILE,EINVAL};int errlen = 4;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (pipe2)(int * pipefd, int flags){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.pipe2_ == NULL){
        FIT::Original.logFile->log_call("pipe2 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.pipe2_(pipefd, flags);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.pipe2_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int * pipefd_rec=pipefd;
    static int flags_rec=flags;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            pipefd_rec==pipefd&&
            flags_rec==flags&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.pipe2_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.pipe2_(pipefd, flags);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            pipefd_rec=pipefd;
            flags_rec=flags;
            
        }
        fire_flag = FIT::Original.pipe2_flag - 1;
        FIT::Original.pipe2_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("pipe2 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("pipe2\n");
        }
        int errList[] = {ENFILE,EFAULT,EMFILE,EINVAL};int errlen = 4;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (_IO_getc)(FILE * stream){
    return getc(stream);
    
}

int (_IO_putc)(int c, FILE * stream){
    return putc(c, stream);
    
}

int (_IO_puts)(const char * s){
    return puts(s);
    
}

int (__fprintf_chk)(FILE * stream, int flag, const char * format, ...){
    va_list va_args;
        va_start(va_args, format);int _rtn = __vfprintf_chk(stream, flag, format, va_args);
        va_end(va_args);
        return _rtn;
}

char * (__fgets_chk)(char * s, size_t size, int strsize, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__fgets_chk_ == NULL){
        FIT::Original.logFile->log_call("__fgets_chk loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__fgets_chk_(s, size, strsize, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__fgets_chk_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static char * s_rec=s;
    static size_t size_rec=size;
    static int strsize_rec=strsize;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            s_rec==s&&
            size_rec==size&&
            strsize_rec==strsize&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__fgets_chk_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                char * ret = FIT::Original.__fgets_chk_(s, size, strsize, stream);
                if (ret!=NULL){
                    FIT::Original.logFile->log_input_str(s, size);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            s_rec=s;
            size_rec=size;
            strsize_rec=strsize;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.__fgets_chk_flag - 1;
        FIT::Original.__fgets_chk_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__fgets_chk ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__fgets_chk\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return NULL;
    }
}

char * (__fgets_unlocked_chk)(char * s, size_t size, int strsize, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__fgets_unlocked_chk_ == NULL){
        FIT::Original.logFile->log_call("__fgets_unlocked_chk loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__fgets_unlocked_chk_(s, size, strsize, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__fgets_unlocked_chk_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static char * s_rec=s;
    static size_t size_rec=size;
    static int strsize_rec=strsize;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            s_rec==s&&
            size_rec==size&&
            strsize_rec==strsize&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__fgets_unlocked_chk_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                char * ret = FIT::Original.__fgets_unlocked_chk_(s, size, strsize, stream);
                if (ret!=NULL){
                    FIT::Original.logFile->log_input_str(s, size);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            s_rec=s;
            size_rec=size;
            strsize_rec=strsize;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.__fgets_unlocked_chk_flag - 1;
        FIT::Original.__fgets_unlocked_chk_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__fgets_unlocked_chk ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__fgets_unlocked_chk\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return NULL;
    }
}

wchar_t * (__fgetws_chk)(wchar_t * ws, size_t size, int strsize, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__fgetws_chk_ == NULL){
        FIT::Original.logFile->log_call("__fgetws_chk loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__fgetws_chk_(ws, size, strsize, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__fgetws_chk_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static wchar_t * ws_rec=ws;
    static size_t size_rec=size;
    static int strsize_rec=strsize;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            ws_rec==ws&&
            size_rec==size&&
            strsize_rec==strsize&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__fgetws_chk_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                wchar_t * ret = FIT::Original.__fgetws_chk_(ws, size, strsize, stream);
                if (ret!=NULL){
                    FIT::Original.logFile->log_input_clx((void*)ws, sizeof(wchar_t), size);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            ws_rec=ws;
            size_rec=size;
            strsize_rec=strsize;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.__fgetws_chk_flag - 1;
        FIT::Original.__fgetws_chk_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__fgetws_chk ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__fgetws_chk\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return NULL;
    }
}

wchar_t * (__fgetws_unlocked_chk)(wchar_t * ws, size_t strsize, int n, FILE * stream){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__fgetws_unlocked_chk_ == NULL){
        FIT::Original.logFile->log_call("__fgetws_unlocked_chk loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__fgetws_unlocked_chk_(ws, strsize, n, stream);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__fgetws_unlocked_chk_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static wchar_t * ws_rec=ws;
    static size_t strsize_rec=strsize;
    static int n_rec=n;
    static FILE * stream_rec=stream;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            ws_rec==ws&&
            strsize_rec==strsize&&
            n_rec==n&&
            stream_rec==stream&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__fgetws_unlocked_chk_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                wchar_t * ret = FIT::Original.__fgetws_unlocked_chk_(ws, strsize, n, stream);
                if (ret!=NULL){
                    FIT::Original.logFile->log_input_clx((void*)ws, sizeof(wchar_t), n);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            ws_rec=ws;
            strsize_rec=strsize;
            n_rec=n;
            stream_rec=stream;
            
        }
        fire_flag = FIT::Original.__fgetws_unlocked_chk_flag - 1;
        FIT::Original.__fgetws_unlocked_chk_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__fgetws_unlocked_chk ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__fgetws_unlocked_chk\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return NULL;
    }
}

ssize_t (__pread64_chk)(int fd, void * ptr, size_t nb, off64_t offset, size_t buflen){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__pread64_chk_ == NULL){
        FIT::Original.logFile->log_call("__pread64_chk loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__pread64_chk_(fd, ptr, nb, offset, buflen);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__pread64_chk_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static void * ptr_rec=ptr;
    static size_t nb_rec=nb;
    static off64_t offset_rec=offset;
    static size_t buflen_rec=buflen;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            /*fxxfxxf*/ ptr_rec==(const void*)((const char*)ptr-sizeof(char))&&
            /*fxxfxxe*/ nb_rec==nb-1&&
            offset_rec==offset&&
            buflen_rec==buflen&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__pread64_chk_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                ssize_t ret = FIT::Original.__pread64_chk_(fd, ptr, nb, offset, buflen);
                if (ret>=0){
                    FIT::Original.logFile->log_input_clx(ptr, 1, ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            ptr_rec=ptr;
            nb_rec=nb;
            offset_rec=offset;
            buflen_rec=buflen;
            
        }
        fire_flag = FIT::Original.__pread64_chk_flag - 1;
        FIT::Original.__pread64_chk_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__pread64_chk ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__pread64_chk\n");
        }
                

                ssize_t ret = FIT::Original.__pread64_chk_(fd, ptr, 1, offset, buflen);
                if (ret>0){
                    FIT::Original.logFile->log_input_clx(ptr, 1, ret);
                }

                
                FIT::insideFIT = false;
                return ret;
    }
}

ssize_t (__pread_chk)(int fd, void * ptr, size_t nb, off_t offset, size_t buflen){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__pread_chk_ == NULL){
        FIT::Original.logFile->log_call("__pread_chk loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__pread_chk_(fd, ptr, nb, offset, buflen);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__pread_chk_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static void * ptr_rec=ptr;
    static size_t nb_rec=nb;
    static off_t offset_rec=offset;
    static size_t buflen_rec=buflen;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            /*fxxfxxf*/ ptr_rec==(const void*)((const char*)ptr-sizeof(char))&&
            /*fxxfxxe*/ nb_rec==nb-1&&
            offset_rec==offset&&
            buflen_rec==buflen&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__pread_chk_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                ssize_t ret = FIT::Original.__pread_chk_(fd, ptr, nb, offset, buflen);
                if (ret>=0){
                    FIT::Original.logFile->log_input_clx(ptr, 1, ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            ptr_rec=ptr;
            nb_rec=nb;
            offset_rec=offset;
            buflen_rec=buflen;
            
        }
        fire_flag = FIT::Original.__pread_chk_flag - 1;
        FIT::Original.__pread_chk_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__pread_chk ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__pread_chk\n");
        }
                

                ssize_t ret = FIT::Original.__pread_chk_(fd, ptr, 1, offset, buflen);
                if (ret>0){
                    FIT::Original.logFile->log_input_clx(ptr, 1, ret);
                }

                
                FIT::insideFIT = false;
                return ret;
    }
}

ssize_t (__read_chk)(int fd, void * ptr, size_t nb, size_t buflen){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.__read_chk_ == NULL){
        FIT::Original.logFile->log_call("__read_chk loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.__read_chk_(fd, ptr, nb, buflen);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.__read_chk_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int fd_rec=fd;
    static void * ptr_rec=ptr;
    static size_t nb_rec=nb;
    static size_t buflen_rec=buflen;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            fd_rec==fd&&
            /*fxxfxxf*/ ptr_rec==(const void*)((const char*)ptr-sizeof(char))&&
            /*fxxfxxe*/ nb_rec==nb-1&&
            buflen_rec==buflen&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.__read_chk_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        
        
				
                ssize_t ret = FIT::Original.__read_chk_(fd, ptr, nb, buflen);
                if (ret>=0){
                    FIT::Original.logFile->log_input_clx(ptr, 1, ret);
                }
                
                FIT::insideFIT = false;
                return ret;
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            fd_rec=fd;
            ptr_rec=ptr;
            nb_rec=nb;
            buflen_rec=buflen;
            
        }
        fire_flag = FIT::Original.__read_chk_flag - 1;
        FIT::Original.__read_chk_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("__read_chk ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("__read_chk\n");
        }
                

                ssize_t ret = FIT::Original.__read_chk_(fd, ptr, 1, buflen);
                if (ret>0){
                    FIT::Original.logFile->log_input_clx(ptr, 1, ret);
                }

                
                FIT::insideFIT = false;
                return ret;
    }
}

int (openat)(int dirfd, const char *pathname, int flags, ...){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.openat_ == NULL){
        FIT::Original.logFile->log_call("openat loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        mode_t mode = 0;
        if ((flags & O_CREAT) != 0)
        {
            va_list arg;
            va_start(arg, flags);
            mode = va_arg(arg, mode_t);
            va_end(arg);
        }
        return FIT::Original.openat_(dirfd, pathname, flags, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.openat_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    /*00AA00:*/ static int dirfd_rec=dirfd;
static const char *pathname_rec=pathname;
static int flags_rec=flags;

    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            /*00AA00:*/ dirfd_rec==dirfd&&
pathname_rec==pathname&&
flags_rec==flags&&

            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.openat_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        mode_t mode = 0;
        if ((flags & O_CREAT) != 0)
        {
            va_list arg;
            va_start(arg, flags);
            mode = va_arg(arg, mode_t);
            va_end(arg);
        }
        return FIT::Original.openat_(dirfd, pathname, flags, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            
            /*00AA00:*/ dirfd_rec=dirfd;
pathname_rec=pathname;
flags_rec=flags;

            
        }
        fire_flag = FIT::Original.openat_flag - 1;
        FIT::Original.openat_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("openat ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("openat\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return -1;
    }
}

int (openat64)(int dirfd, const char *pathname, int flags, ...){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.openat64_ == NULL){
        FIT::Original.logFile->log_call("openat64 loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        mode_t mode = 0;
        if ((flags & O_CREAT) != 0)
        {
            va_list arg;
            va_start(arg, flags);
            mode = va_arg(arg, mode_t);
            va_end(arg);
        }
        return FIT::Original.openat64_(dirfd, pathname, flags, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.openat64_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    /*00AA00:*/ static int dirfd_rec=dirfd;
static const char *pathname_rec=pathname;
static int flags_rec=flags;

    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            /*00AA00:*/ dirfd_rec==dirfd&&
pathname_rec==pathname&&
flags_rec==flags&&

            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.openat64_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        mode_t mode = 0;
        if ((flags & O_CREAT) != 0)
        {
            va_list arg;
            va_start(arg, flags);
            mode = va_arg(arg, mode_t);
            va_end(arg);
        }
        return FIT::Original.openat64_(dirfd, pathname, flags, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            
            /*00AA00:*/ dirfd_rec=dirfd;
pathname_rec=pathname;
flags_rec=flags;

            
        }
        fire_flag = FIT::Original.openat64_flag - 1;
        FIT::Original.openat64_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("openat64 ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("openat64\n");
        }
        errno = EAGAIN;
        FIT::insideFIT = false;
        return -1;
    }
}

int (renameat)(int olddirfd, const char * oldpath, int newdirfd, const char * newpath){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.renameat_ == NULL){
        FIT::Original.logFile->log_call("renameat loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.renameat_(olddirfd, oldpath, newdirfd, newpath);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.renameat_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int olddirfd_rec=olddirfd;
    static const char * oldpath_rec=oldpath;
    static int newdirfd_rec=newdirfd;
    static const char * newpath_rec=newpath;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            olddirfd_rec==olddirfd&&
            oldpath_rec==oldpath&&
            newdirfd_rec==newdirfd&&
            newpath_rec==newpath&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.renameat_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.renameat_(olddirfd, oldpath, newdirfd, newpath);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            olddirfd_rec=olddirfd;
            oldpath_rec=oldpath;
            newdirfd_rec=newdirfd;
            newpath_rec=newpath;
            
        }
        fire_flag = FIT::Original.renameat_flag - 1;
        FIT::Original.renameat_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("renameat ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("renameat\n");
        }
        errno = ENOMEM;
        FIT::insideFIT = false;
        return -1;
    }
}

int (mkfifoat)(int dirfd, const char * pathname, mode_t mode){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.mkfifoat_ == NULL){
        FIT::Original.logFile->log_call("mkfifoat loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.mkfifoat_(dirfd, pathname, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.mkfifoat_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int dirfd_rec=dirfd;
    static const char * pathname_rec=pathname;
    static mode_t mode_rec=mode;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            dirfd_rec==dirfd&&
            pathname_rec==pathname&&
            mode_rec==mode&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.mkfifoat_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.mkfifoat_(dirfd, pathname, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            dirfd_rec=dirfd;
            pathname_rec=pathname;
            mode_rec=mode;
            
        }
        fire_flag = FIT::Original.mkfifoat_flag - 1;
        FIT::Original.mkfifoat_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("mkfifoat ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("mkfifoat\n");
        }
        int errList[] = {EBADF,ENOTDIR};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (symlinkat)(const char * oldpath, int newdirfd, const char * newpath){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.symlinkat_ == NULL){
        FIT::Original.logFile->log_call("symlinkat loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.symlinkat_(oldpath, newdirfd, newpath);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.symlinkat_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static const char * oldpath_rec=oldpath;
    static int newdirfd_rec=newdirfd;
    static const char * newpath_rec=newpath;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            oldpath_rec==oldpath&&
            newdirfd_rec==newdirfd&&
            newpath_rec==newpath&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.symlinkat_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.symlinkat_(oldpath, newdirfd, newpath);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            oldpath_rec=oldpath;
            newdirfd_rec=newdirfd;
            newpath_rec=newpath;
            
        }
        fire_flag = FIT::Original.symlinkat_flag - 1;
        FIT::Original.symlinkat_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("symlinkat ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("symlinkat\n");
        }
        int errList[] = {EBADF,ENOTDIR};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (mkdirat)(int dirfd, const char * pathname, mode_t mode){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.mkdirat_ == NULL){
        FIT::Original.logFile->log_call("mkdirat loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.mkdirat_(dirfd, pathname, mode);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.mkdirat_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int dirfd_rec=dirfd;
    static const char * pathname_rec=pathname;
    static mode_t mode_rec=mode;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            dirfd_rec==dirfd&&
            pathname_rec==pathname&&
            mode_rec==mode&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.mkdirat_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.mkdirat_(dirfd, pathname, mode);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            dirfd_rec=dirfd;
            pathname_rec=pathname;
            mode_rec=mode;
            
        }
        fire_flag = FIT::Original.mkdirat_flag - 1;
        FIT::Original.mkdirat_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("mkdirat ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("mkdirat\n");
        }
        int errList[] = {EBADF,ENOTDIR};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (unlinkat)(int dirfd, const char * pathname, int flags){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.unlinkat_ == NULL){
        FIT::Original.logFile->log_call("unlinkat loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.unlinkat_(dirfd, pathname, flags);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.unlinkat_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int dirfd_rec=dirfd;
    static const char * pathname_rec=pathname;
    static int flags_rec=flags;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            dirfd_rec==dirfd&&
            pathname_rec==pathname&&
            flags_rec==flags&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.unlinkat_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.unlinkat_(dirfd, pathname, flags);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            dirfd_rec=dirfd;
            pathname_rec=pathname;
            flags_rec=flags;
            
        }
        fire_flag = FIT::Original.unlinkat_flag - 1;
        FIT::Original.unlinkat_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("unlinkat ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("unlinkat\n");
        }
        int errList[] = {EBADF,ENOTDIR};int errlen = 2;errno = errList[rand() % errlen]; //pick uniform random error
        FIT::insideFIT = false;
        return -1;
    }
}

int (fchmodat)(int dirfd, const char * pathname, mode_t mode, int flags){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fchmodat_ == NULL){
        FIT::Original.logFile->log_call("fchmodat loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fchmodat_(dirfd, pathname, mode, flags);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fchmodat_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int dirfd_rec=dirfd;
    static const char * pathname_rec=pathname;
    static mode_t mode_rec=mode;
    static int flags_rec=flags;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            dirfd_rec==dirfd&&
            pathname_rec==pathname&&
            mode_rec==mode&&
            flags_rec==flags&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fchmodat_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.fchmodat_(dirfd, pathname, mode, flags);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            dirfd_rec=dirfd;
            pathname_rec=pathname;
            mode_rec=mode;
            flags_rec=flags;
            
        }
        fire_flag = FIT::Original.fchmodat_flag - 1;
        FIT::Original.fchmodat_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fchmodat ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fchmodat\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (fchownat)(int dirfd, const char * pathname, uid_t owner, gid_t group, int flags){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.fchownat_ == NULL){
        FIT::Original.logFile->log_call("fchownat loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.fchownat_(dirfd, pathname, owner, group, flags);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.fchownat_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int dirfd_rec=dirfd;
    static const char * pathname_rec=pathname;
    static uid_t owner_rec=owner;
    static gid_t group_rec=group;
    static int flags_rec=flags;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            dirfd_rec==dirfd&&
            pathname_rec==pathname&&
            owner_rec==owner&&
            group_rec==group&&
            flags_rec==flags&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.fchownat_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.fchownat_(dirfd, pathname, owner, group, flags);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            dirfd_rec=dirfd;
            pathname_rec=pathname;
            owner_rec=owner;
            group_rec=group;
            flags_rec=flags;
            
        }
        fire_flag = FIT::Original.fchownat_flag - 1;
        FIT::Original.fchownat_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("fchownat ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("fchownat\n");
        }
        errno = EINTR;
        FIT::insideFIT = false;
        return -1;
    }
}

int (linkat)(int olddirfd, const char * oldpath, int newdirfd, const char * newpath, int flags){
    if (!FIT::initialised_flag && !FIT::insideFIT){
        __FIT__injectionInit();
    }
    //self check
    if (FIT::Original.linkat_ == NULL){
        FIT::Original.logFile->log_call("linkat loading error\n");
        __FIT__injectionFin();
        abort();
    }
    if(FIT::insideFIT){
        
        return FIT::Original.linkat_(olddirfd, oldpath, newdirfd, newpath, flags);
        
    }
    FIT::insideFIT = true;
    static int fire_flag = FIT::Original.linkat_flag - 1; // the condition to fire fault injection

    bool recovery_detect = false;
    /* recovery arguments */
    static bool expect_recovery= false;
    //declare variables
    static int olddirfd_rec=olddirfd;
    static const char * oldpath_rec=oldpath;
    static int newdirfd_rec=newdirfd;
    static const char * newpath_rec=newpath;
    static int flags_rec=flags;
    
    if (FIT::Original.injection_flag && FIT::Original.recovery_flag){
        if(expect_recovery){
            recovery_detect =
            olddirfd_rec==olddirfd&&
            oldpath_rec==oldpath&&
            newdirfd_rec==newdirfd&&
            newpath_rec==newpath&&
            flags_rec==flags&&
            true;
            //Implement checking
            if (recovery_detect){
                expect_recovery = false;
            }
        }
    }

    if (!FIT::Original.injection_flag || !opTest(FIT::Original.linkat_flag, fire_flag) || recovery_detect){
        fire_flag--;
        expect_recovery = false;
        FIT::insideFIT = false;
        
        return FIT::Original.linkat_(olddirfd, oldpath, newdirfd, newpath, flags);
        
    } else {
        if (FIT::Original.recovery_flag){
            //Set recovery expectation
            expect_recovery = true;
            //store_statics
            olddirfd_rec=olddirfd;
            oldpath_rec=oldpath;
            newdirfd_rec=newdirfd;
            newpath_rec=newpath;
            flags_rec=flags;
            
        }
        fire_flag = FIT::Original.linkat_flag - 1;
        FIT::Original.linkat_count++;
        if (FIT::Original.debugmode_flag){
            FIT::Original.logFile->log_call("linkat ");
            void* backtrace_arr[3];
            size_t backtrace_size = backtrace(backtrace_arr, 3);
            int addrstrlim = 6*(sizeof(void*)+2) + 3;
            char addresses[addrstrlim];
            int str_ret = sprintf(addresses, "%p %p\n", backtrace_arr[1], backtrace_arr[2]);
            if (backtrace_size<2 && str_ret > addrstrlim)
            {
                FIT::Original.logFile->log_call("Tracking Error\n");
                __FIT__injectionFin();
                abort();
            }
            FIT::Original.logFile->log_call(addresses);
        } else {
            FIT::Original.logFile->log_call("linkat\n");
        }
        errno = EIO;
        FIT::insideFIT = false;
        return -1;
    }
}


}